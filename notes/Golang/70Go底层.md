title: 70.Go底层
date: 2020-05-24
tags: Go
categories: Go语言
layout: post

------

摘要：本节介绍`Go`语言底层的一些用法，虽然有风险，但对于了解`Go`的实现细节有帮助...

<!-- more -->

`Go`语言提供了`unsafe`包，为用户开放一些偏向底层的黑魔法

- 可以实现更好的性能
- 与其它语言进行互操作
- 摆脱`Go`语言规则带来的限制

但同时也要承担一些不良后果

- 可能会导致与未来版本的不兼容，一些实现细节可能变化
- 实现逻辑比较隐晦，可能导致无法预测的错误

被广泛地用于比较低级的包，如：`runtime`、`os`、`syscall`和`net`包等。这些包中的实现需要和操作系统密切配合。对于普通的程序一般不需要使用`unsafe`包

## 内存布局和优化

在`unsafe`包中，有关内存布局和优化的方法是**安全的**

### 内存布局

计算机在加载和保存数据时，如果内存地址合理地对齐将会更有效率

- `int16`类型的变量地址是`2`字节对齐
- `rune`类型变量地址是`4`字节对齐
- `float64`、`uint64`、`unitptr`类型变量地址是`8`字节对齐

聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在**内存空洞**（编译器自动添加的未被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐）

| 类型                            | 大小                            |
| ------------------------------- | ------------------------------- |
| `bool`                          | 1个字节                         |
| `intN, uintN, floatN, complexN` | N/8个字节(例如float64是8个字节) |
| `int, uint, uintptr`            | 1个机器字                       |
| `*T`                            | 1个机器字                       |
| `string`                        | 2个机器字(data,len)             |
| `[]T`                           | 3个机器字(data,len,cap)         |
| `map`                           | 1个机器字                       |
| `func`                          | 1个机器字                       |
| `chan`                          | 1个机器字                       |
| `interface`                     | 2个机器字(type,value)           |

我们来看一个具体的例子：

```go
// BFI 3word
type BFI struct {
	b bool
	f float64
	i int16
}
// FIB 2word
type FIB struct {
	f float64
	i int16
	b bool
}
//BIF 2word
type BIF struct {
	b bool
	i int16
	float64
}
func main() {
	fmt.Println("BFI的内存:", unsafe.Sizeof(BFI{}))
	fmt.Println("FIB的内存:", unsafe.Sizeof(FIB{}))
	fmt.Println("BIF的内存:", unsafe.Sizeof(BIF{}))
}
//输出结果
BFI的内存: 24
FIB的内存: 16
BIF的内存: 16
```

有效的包装可以使数据结构更加紧凑，内存使用率和性能都可能会受益

### Sizeof()

函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值

```go
import "unsafe"
fmt.Println(unsafe.Sizeof(float64(0))) // "8"
```

函数返回的大小只包括数据结构中固定的部分，例如：字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容

### Alignof()

函数返回对应参数的类型需要对齐的倍数

```go
fmt.Println("Int8的对齐", unsafe.Alignof(int8(0)))
fmt.Println("Int的对齐", unsafe.Alignof(int(0)))
fmt.Println("Bool的对齐", unsafe.Alignof(bool(true)))
fmt.Println("String的对齐", unsafe.Alignof("("))
// 输出结果
Int8的对齐 1
Int的对齐 8
Bool的对齐 1
String的对齐 8
```

### Offsetof()

函数的参数必须是字段 `x.f`，返回 `f` 字段相对于 `x` 起始地址的偏移量，包括可能的空洞

![偏移量](.\assets\ch13-01.png)

```go
var x struct {
    a bool
    b int16
    c []int
}
fmt.Println("变量X中a的偏移量：", unsafe.Offsetof(x.a))
fmt.Println("变量X中b的偏移量：", unsafe.Offsetof(x.b))
fmt.Println("变量X中c的偏移量：", unsafe.Offsetof(x.c))
// 输出结果
变量X中a的偏移量： 0
变量X中b的偏移量： 2
变量X中c的偏移量： 8
```

## 指针类型

大多数指针类型会写成`*T`，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的`void*`类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过`*p`来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。

一个普通的`*T`类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的`*T`类型相同。通过将`*float64`类型指针转化为`*uint64`类型指针，我们可以查看一个浮点数变量的位模式。