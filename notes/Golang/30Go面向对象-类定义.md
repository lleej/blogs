title: 30.Go面向对象之类定义
date: 2020-04-29
tags: Go
categories: Go语言
layout: post

------

摘要：本节介绍`Go`语言的面向对象中的类定义。`Go`中没有`class`这样专门的类定义语法

<!-- more -->

## 类定义

`Go`语言没有与其他语言一样清晰的`OOP`定义，如：使用`class`声明一个类。在`Go`中任何类型（除：指针和接口外）都是类，统一使用`type`命名类型定义，类方法使用方法声明语句定义

### 类型=类

在`Go`中，使用`type`声明的命名类型就是`类声明`。但是`type`类型声明中并没有包含方法声明，`Go`中的类声明将类型声明和方法声明分开。这样的优点是，可以给任何**命名类**添加方法，即使该类源自第三方包（不推荐随意添加类方法）

### 方法声明

在类声明中，使用方法这种特殊的函数，和类型建立关联。注意：方法声明是独立于类型声明之外的

在函数声明时，函数名前附加一个参数，即是**方法声明**。这样就将函数作为方法绑定到类型上，只能通过类型访问该函数

```go
func (variable typename) name(parameter-list) (result-list) {
    body
}
```

我们来看一个例子：

```go
package geometry

import "math"

type Point struct{ X, Y float64 }

// 传统的函数表达
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// 类型Point的方法
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

上例中，附加的参数`p`，称为方法的接收器(`receiver`)，与面向对象语言中的`this`或`self`同义，但可以任意指定名称。一般情况下，这个参数的名字用类型的第一个小写字母表示。本例中类型为`Point`，参数名为`p`

我们可以给同一个包内任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者接口

注意：不能给内置类型声明新方法

```go
func (i int) Add(j int) int { //compile error: cannot define new methods on non-local type int
	return i + j
}
```

### 指针对象的方法

即方法接收器的参数类型是指针类型时，我们称为指针对象的方法

调用方法时，会对接收器进行**值拷贝**。如果方法需要更新接收器参数或接收器参数过大，就希望避免值拷贝而使用指针

```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```

声明方法的`receiver`是指针还是非指针类型，需要考虑两方面因素

- 对象的大小。声明为非指针变量时，会产生一次值拷贝（消耗时间和内存空间）
- 如果使用指针，那么`receiver`与对象实例指向的永远是同一块内存地址

### 命名空间

虽然本例中有两个函数的名称都是`Distance`，但并不冲突：

- 第一个是包级的函数
- 第二个是类型的方法

在一个类/类型声明中，所有成员和方法的名称不能相同（不包括继承的方法）

```go
func (p Point) X() { // type Point has both field and method named X
  ...
}
```

## 实例化

类的实例化与其他类型的实例化相同，可以用字面量、`new`函数，或者部分类型使用`make函数`等

```go
p1 := Point{1, 2}
p2 := *new(Point) //初始化为0值
```

### 方法调用

方法的调用使用`.`操作符，也称为**选择器**，语法上同`struct`类型中的成员访问一样

在方法中，可以直接使用接收器这个参数值，类似于`self`缺省是方法的第一个参数一样

```go
p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // "5", function call
fmt.Println(p.Distance(q))  // "5", method call
```

### 指针对象的方法

对于接收器是指针类型的方法，严格意义上讲应该使用指针变量进行访问

```go
// 第一种方法
r := &Point{1, 2}
r.ScaleBy(2)
// 第二种方法
p := Point{1, 2}
pptr := &p
pptr.ScaleBy(2)
// 第三种方法
p := Point{1, 2}
(&p).ScaleBy(2) // 注意括号的位置，不加则是&(p.ScaleBy(2))的意思
```

也可以用简短的写法，编译器会隐式地帮我们用`&p`去调用`ScaleBy`这个方法

```go
p := Point{1, 2}
p.ScaleBy(2)
```

注意：我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到

```go
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

不管方法的`receiver`是指针类型还是非指针类型，都是可以通过指针/非指针类型调用，编译器做了类型转换

- `receiver`的实参和形参相同，如：都是类型`T`或者都是类型`*T`

```go
Point{1, 2}.Distance(q) //  Point
pptr.ScaleBy(2)         // *Point
```

- `receiver`实参是类型`T`，但形参是类型`*T`，编译器会隐式地为我们取变量的地址

```go
p.ScaleBy(2) // implicit (&p)
```

- `receiver`实参是类型`*T`，形参是类型`T`，编译器会隐式地为我们**解引用`(*T)`**取到指针指向的实际变量

```go
pptr.Distance(q) // implicit (*pptr)
```

