title: 34.Go面向对象之类型断言
date: 2020-05-10
tags: Go
categories: Go语言
layout: post

------

摘要：本节介绍`Go`语言的面向对象中的类型断言。包括：

<!-- more -->

## 是什么

类型断言：判断一个接口的类型与断言类型是否匹配。具体的语法如下：

```go
val, ok = x.(T)
```

- `x`：接口类型的变量
- `T`：断言类型
- `val`：断言后的变量
- `ok`：类型是否匹配

其实就是，如果`x`与`T`类型匹配（接口匹配或类型匹配），则返回的`ok`为`true`，否则`ok`为`false`

## 为什么

对于接口来说，其接口的类型和接口的值都是可以动态改变的。在面向对象编程中，需要在运行时判断接口的动态类型，根据被访问对象是否与特定类型匹配，从而进一步处理业务逻辑

## 怎么做

通过下例进行说明，本例中定义了`3`个接口类型以及`2`个类

```go
// Customer 顾客接口
type Customer interface {
	Buy(item string) // 买东西
}
// Producer 厂家接口
type Producer interface {
	Produce(item string) // 生成商品
}
// Maller 商家接口
type Maller interface {
	Sell(item string) // 销售商品
}
// Nike 实体类
type Nike struct {
	ID   int
	Name string
}
// Produce 作为厂家生产商品
func (n *Nike) Produce(item string) {
	fmt.Println("Nike Produce" + item)
}
// Sell 作为卖家 销售商品
func (n *Nike) Sell(item string) {
	fmt.Println("Nike Sell" + item)
}
// TMall 天猫
// 定义不一样的数据结构
type TMall struct {
	ID   string
	Name string
	Addr string
}
// Produce 天猫能生成商品
func (n *TMall) Produce(item string) {
	fmt.Println("TMall Produce" + item)
}
// Sell 天猫能销售商品
func (n *TMall) Sell(item string) {
	fmt.Println("TMall Sell" + item)
}
// Buy 天猫能买东西
func (n *TMall) Buy(item string) {
	fmt.Println("TMall Buy" + item)
}

func main() {
	var p Producer // 定义厂家接口变量 p
  fmt.Printf("%T, %[1]v\n", p) // 输出：<nil>, <nil>
	p = &Nike{1, "Nike"}  // 创建一个Nike实体对象
	fmt.Printf("%T, %[1]v\n", p) // 输出：*main.Nike, &{1 Nike}
  t, ok := p.(*TMall) // 断言是否与TMall匹配?
	fmt.Printf("%T, %[1]v, %v\n", t, ok) // 输出：*main.TMall, <nil>, false
	t, ok := p.(Maller) // 断言是否与Maller匹配?
	fmt.Printf("%T, %[1]v, %v\n", t, ok) // 输出：*main.Nike, &{1 Nike}, true
	b, ok := p.(Customer) // 断言是否与Customer匹配？
	fmt.Printf("%T, %[1]v, %v\n", b, ok) // 输出：<nil>, <nil>, false
}

```

- `x`必须是接口类型
- 断言类型`T`可以是接口类型或者实体类
- 断言成功，根据断言类型`T`有不同判定标准
  - 断言类型`T`为接口类型：意味着`x`的接口方法能够覆盖`T`的接口方法
  - 断言类型`T`为实体类型：`x`的类型与`T`类型一致，必须是同样的类型
- 断言失败，`x`的类型有两种情况
  - 断言类型`T`为接口类型：`x`的类型和值都为零值`nil`
  - 断言类型`T`为实体类型：`x`的类型为`T`，值为零值`nil`

## 应用场景

### 区别错误类型

`Go`中的`error`是一个接口类型，只有一个返回错误描述字符串的方法`Error()`。如果要区分返回的错误具体是哪种错误，首先就需要知道实现该接口的具体类型，以及其错误代码

**可能有人会说，从返回的错误描述字符串中查找关键字，不是非常简单吗？可是对于不同的系统平台，有可能返回的错误描述会存在差异；而且这种改动可能非常隐蔽**

我们来看`Go`中是如何做的。这段代码是`PathError`错误实体类的定义，由三个属性和一个接口方法组成

```go
package os

// PathError records an error and the operation and file path that caused it.
type PathError struct {
    Op   string
    Path string
    Err  error
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

如何判断返回的错误是预期的错误呢？例如：文件不存在

```go
import (
    "errors"
    "syscall"
)

var ErrNotExist = errors.New("file does not exist")

// IsNotExist returns a boolean indicating whether the error is known to
// report that a file or directory does not exist. It is satisfied by
// ErrNotExist as well as some syscall errors.
func IsNotExist(err error) bool {
    if pe, ok := err.(*PathError); ok {
        err = pe.Err
    }
    return err == syscall.ENOENT || err == ErrNotExist
}
```

我们用代码调试工具看看，具体的错误对象的内容

```go
_, err := os.Open("/no/such/file")
fmt.Println(os.IsNotExist(err)) // "true"
```

通过添加断点的方式，跟踪到了`err`变量的值

![错误内存信息](./assets/image-20200512171611778.png)

可以看到，变量是`PathError`类型，其`Err`属性是`syscall.ErrNo`类型的值，`2`代表文件不存在

我们再返回`IsNotExists`函数的代码，就非常清楚了

- `err.(*PathError)`：进行类型的判断，是否是`PathError`类型，如果是则取出其中保存的`error`错误值，判断类型的原因就是为了取出其中包含的`Err`属性值而已
- 比较错误值，如果是`syscall.ENOENT`还是前面定义的`errors.New("file does not exist")`

