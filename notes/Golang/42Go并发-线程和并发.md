title: 42.Go并发之线程和并发
date: 2020-05-19
tags: Go
categories: Go语言
layout: post

------

摘要：本节将细致地解释`goroutine`和操作系统线程之间的技术上的一些区别

<!-- more -->

## 动态栈

### 线程

每个线程都会分配**固定大小**的内存栈（一般是`2M`），用来存储正在被调用或挂起的函数的内部变量

固定大小的内存栈，有利：处理简单、通常情况够用；弊端：线程数量受限、可能浪费也可能不够

### `goroutine`

每个`goroutine`会分配**动态**的内存栈（从`2K`开始，最大可到`1G`），用来存储正在被调用或挂起的函数的内部变量

动态伸缩的内存栈，有利：充分利用内存空间、`goroutine`数量最大；弊端：管理复杂、对齐问题

## 调度

### 线程

由操作系统的内核进行调度：

- 硬件计时器每隔几毫秒中断处理器，并调用`scheduler`内核函数
- 挂起当前执行的线程，并将寄存器的内容**保存**到内存中
- 检查线程列表并决定接下来运行的线程
- 从内存中恢复该线程的寄存器内容
- 恢复执行该线程的现场并开始执行线程

线程被内核调度，线程间的切换包含完整的上下文切换过程：保存线程`A`的寄存器到内存、从内存恢复线程`B`到寄存器、更新调度器的数据结构。这些过程需要多次访问内存，切换开销大，增加了运行的`cpu`周期

### `goroutine`

由`Go`的调度器进行调度

- 使用一些技术手段，如`m:n`调度（在`n`个线程上调度`m`个`goroutine`）
- 工作原理与内核调度相似，但程序间独立
- 并非使用硬件定时器，由`Go`架构调度（如：`Sleep`或`channel`或`mutex`）
- 调度器会使`A`进入休眠，并开始执行`B`，直到时机到了再去唤醒`A`
- 不需要进入内核的上下文，调度代价要低

## GOMAXPROCS

虽然`Go`有自己的调度器，而且其调度性能要高于线程调度。但真正运行程序的是操作系统的线程，因此，需要最大化的利用操作系统的线程为程序的并发服务

在`Go`语言中，可以通过使用`GoMaxProcs`函数或者命令行参数的方式，设置使用的线程数量。该数量默认与`CPU`逻辑核数相等

```go
// 代码中设置
runtime.GOMAXPROCS(runtime.NumCPU())
// 命令行参数设置
GOMAXPROCS=2 go run xxx.go
```

执行下面的代码，通过设置不同的`GOMAXPROCS`值，可以看到不同的输出效果

```go
for {
    go fmt.Print(0)
  	go fmt.Print(1)
  	go fmt.Print(2)
    fmt.Print(3)
}
```

- 为`1`时

  ```go
  333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333302012012012012012012012012012012012012012012012012012012001201201201201201201201201201201201201201201201201201201201201120120120120201201201201201201201201201220120120
  ```

  可以看出，在单线程下，`main goroutine`会分配更长的时间片，而`work goroutine`们平均分配时间片

- 为`2`时

  ```go
  333302120103120110302222133001233322001133012101333112120233311022013332012002012013120100333332221101201200330121013332202233001202010133333222033332111121011012100212333021022100301220120012333212201210100333333312112233020020122010013333111022033321222020013300102011103302
  ```

  可以看出，在多个线程下，`main goroutine`所在的线程依然分配更多的时间片，但`work goroutine`们的时间片分配并不均匀，可能被分配到不同的线程中

- 为`3`时

  ```go
  013201330221313010133331020122122332021001020330231122001331123300121330102221232211300233331221023101002003333212100113330120210202110220133333022120110333011123220220020330013331111002333333221102010333221112002222011021013212001033333330021320211212001201200120133330022011
  ```

  可以看出，在进一步增加线程数量后，`main goroutine`和`work goroutine`的时间片分配趋向于更加的平均

- 为`4`时

  ```go
  013230210333333333020121121101020100222202121133333333332102010011212301200122231220110020333333322213012001210121012013300220013330100133321012010211011022233330111021222033333330332120020122011220200121333330011221210210122033310100333333133212221021201203333301101120122010
  ```

  可以看出，在进一步增加线程数量后，`main goroutine`和`work goroutine`的时间片分配趋向于更加的平均

## ID号

### 线程

支持多线程的操作系统和程序语言中，线程有独特的身份`ID`，以普通值（`integer`或`pointer`）的形式表示，可以很容易获取到

除了可以通过这个`ID`，对线程进行控制（如：暂停、终止等）外，还可以建立线程安全的数据共享机制：线程本地存储(`thread-local storage`)，一个以线程`id`作为`key`的共享存储的`map`，每个线程以其`id`从中读写数据，线程间互不冲突

利用`ID`进行控制和数据共享，对于程序来说有利有弊。如果线程的执行部分与线程的身份相关联，可能会造成行为变得不可预测

### `goroutine`

`Go`鼓励更为简单的模式，这种模式下参数对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。在`Go`语言中`goroutine`是没有`ID`的