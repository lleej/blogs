title: 108.Go命令之go fmt
date: 2020-04-15
tags: Go命令
categories: Go命令
layout: post

------

摘要：本节介绍`Go`命令中的`go fmt`代码格式化命令...

<!-- more -->

## 用途

按照`Go`语言代码规范，格式化指定代码包中所有`Go`语言源码文件的代码。通俗的讲，就是一个代码格式化的命令。

**命令格式**

 ```bash
$ go fmt 包名
 ```

与`go doc`与`godoc`的关系相同，`go fmt`也有一个对应的`gofmt`的命令。其实，`go fmt`是`gofmt`的一个简单的封装

```bash
$ go fmt -n hello
c:\go\bin\gofmt.exe -l -w hello_test.go
c:\go\bin\gofmt.exe -l -w hello.go
```

可以看到，格式化具体执行的指令是`gofmt -l -w`，而且只格式化`hello`包中的所有源代码文件

## 改写规则

在默认情况下，对源码文件的改写操作包括如下几个方面

- 依赖包导入，以字典序排序代码包导入路径的先后顺序
- 标准化各个语言或语句块之间的缩进、空格和换行。比如，把所有的`\r\n`转换成`\n`
- 对代码语法的小修正。比如，消除用于判断变量类型的switch语句块中多余的圆括号

对代码的简化操作包括以下几个方面

- 消除在数组/切片初始化中不必要的类型声明
- 消除在字典初始化中不必要的类型声明
- 消除在数组/切片切片操作时不必要的索引指定
- 消除迭代时的非必要临时变量赋值操作

## 命令标记

这里介绍的其实是`gofmt`的命令标记，同样适用于`go fmt`命令

| 标记名称    | 标记描述                                                     |
| ----------- | ------------------------------------------------------------ |
| -cpuprofile | 把CPU概要写入指定文件。文件的路径应该作为此标记的值          |
| -d          | 显示格式化前后的不同（如果有的话），而不是直接格式化那些代码 |
| -e          | 报告目标源码文件中的所有错误。默认情况下，仅会显示前10个错误 |
| -l          | 仅把那些不符合格式化规范的、需要被命令程序改写的源码文件的绝对路径打印到标准输出。<br />而不是把改写后的全部内容都打印到标准输出。 |
| -r          | 添加形如“a[b:len(a)] -> a[b:]”的重写规则。如果需要自定义额外的格式化规则，就需要用到它<br />规则字符串应该作为此标记的值 |
| -s          | 简化文件中的代码                                             |
| -w          | 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出 |

### `-r`自定义替换

可以在执行命令时，使用自定义的替换规则，对源代码文件进行修正

```bash
$ gofmt -r="a[b:len(a)] -> a[b:]"
```

- 使用`-r=`命令标记
- `->`标记值中必须包含该字符
- `->`左侧是被替代表达式
- `->`右侧是替代表达式
- 必须使用""包含

使用`-r`标记后，在解析源码文件之前，会将此标记值中的被替换表达式和替换表达式，分别解析为抽象语法树的表达式节点。也就是说：不是通常意义上说的文字替换`replace`，而是语法层面的替换

`gofmt`默认支持以下替换操作

- 程序实体名替换，包括变量、常量、函数、结构体和接口。如：`-r="array1 -> array2"`和`-r="FuncA -> FuncB"`
- 程序实体类型替换，包含函数的参数和结果的类型替换。比如：`-r="string->bool"`和`-r="interface{}->int"`
- 多余圆括号的清除。比如：`-r="(x)->x"`作用于代码就是：`a = (-x.s)`替换为`a = -x.s`、`((b = -x.f()))`替换为`b = -x.f()`、`c = -(x).f`替换为`c = -x.f`，但不会去掉`d = (&x).s`和`e = (-x).f()`中的圆括号。在不改变语义和不产生语法歧义的前提下清除代码中多余的圆括号
- 数值操作的替换。比如：`-r="x+x -> x*2"`作用于代码就是：`x + x`替换为`x * 2`。如果需要被替换的表达式中包含注释，会去掉这些注释。比如，`x /* It's comment */ + x`替换为`x * 2`
- 基于参数列表的函数调用替换。比如：`-r="funcA(a) -> FuncA(a, c)"`作用于目标代码，则所有函数名为`funcA`并以一个变量作为参数（不关心参数名是什么）的语句都会被替换为调用函数`FuncA`并以变量`a`和变量`c`作为参数的语句。