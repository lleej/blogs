title: 81.Go常用包-viper
date: 2020-06-29
tags: Go包
categories: Go语言
layout: post

------

摘要：本节介绍一个配置解决方案，可以解决配置文件的读/写/监控操作，支持多种文件格式，将关注点回归到业务本身...

<!-- more -->

> 地址：http://github.com/spf13/viper
>
> 文档：

## 安装

```shell
go get -u github.com/spf13/viper
```

## 特点

- 支持`JSON`、`TOML`、`YAML`、`HCL`、`Java Properties`、`Ini`等多种文件格式
- 支持`etcd`、`consul`等多种远程配置服务
- 支持监控配置的变化、并自动加载（可以提供事件触发）
- 支持从命令行、环境变量、配置文件、字节流等多种`io`端读取配置
- 支持显示设置键值、设置默认值等

## 优先级

配置参数可以通过多种途径获取（如：命令行、环境变量、配置文件、默认值），其最终的值取决于获取途径的优先级

**命令行 > 环境变量 > 配置文件 > 默认值**

## 使用

介绍`viper`包的一般用法，以及在使用中一些常见的坑

### 配置文件

从配置文件中读取配置项，是应用程序的常用做法。`viper`的不同之处是：支持大多数常用的配置文件格式

#### 文件类型

从`viper`的源代码中，可以看出其支持的文件类型

```go
// viper v1.7.0
SupportedExts = []string{"json", "toml", "yaml", "yml", "properties", "props", "prop", "hcl", "dotenv", "env", "ini"}
```

#### 示例

先看一个读写配置文件的示例

```go
import "github.com/spf13/viper"

type dbConfig struct {
	Name     string
	UserName string
	PassWord string
	Dbtype   string
}

type config struct {
	AddRess string
	Port    int64
	Flag    bool
	Db      dbConfig
	Lists   []string
}

func writeInitConfig() {
	viper.Set("Address", "0.0.0.0")
	viper.Set("Port", 9000)
	viper.Set("Flag", bool(true))
	viper.Set("DB", map[string]string{"Name": "HelloDB", "UserName": "root", "PassWord": "root", "dbType": "mySql"})
	viper.Set("Lists", []string{"Go", "Erlang", "Python", "Delphi"})
	if err := viper.WriteConfigAs("./config/hello.yaml"); err != nil {
		fmt.Printf("写配置文件hello.yaml失败：%s\n", err)
	}    
}

func main() {
    //viper.SetConfigFile("./config/hello.yaml")
	viper.SetConfigName("hello")
	viper.SetConfigType("yaml")
	viper.AddConfigPath("./config/")
	if err := viper.ReadInConfig(); err != nil {
		fmt.Printf("读取配置文件失败：%s。稍后进行初始化...\n", err)
		writeInitConfig()
	}
   	fmt.Println("Read Port:", viper.Get("Port"))
	fmt.Println("db.username:", viper.Get("db.username"))

    var cfg config
	viper.Unmarshal(&cfg) // 将配置项读取到
	fmt.Printf("Address: %s\n", cfg.AddRess)
	fmt.Printf("DB：%+v\n", cfg.Db)
	fmt.Printf("Lists：%#v\n", cfg.Lists)    
}
```

#### 配置文件源

`viper`提供了两种设置配置文件源的方式

- `One`：一次搞定

  ```go
  import "github.com/spf13/viper"
  viper.SetConfigFile("./config/settings.yaml") // 参数是配置文件的完整文件名，包括目录、文件名称、扩展名
  ```

  `viper`根据传入的完整文件名，自动拆分出文件名、类型和目录

- `Two`：分开设置

  ```go
  import "github.com/spf13/viper"
  viper.SetConfigName("settings")		// 配置文件名称，无路径、无后缀
  viper.SetConfigType("yaml")			// 配置文件类型，必须是支持的类型之一
  viper.AddConfigPath("./config/")	// 添加配置文件搜索的路径，可以调用多次，按照执行顺序查找文件
  ```

  可以添加多个查找目录，`viper`会按添加的顺序来查找配置文件

两者的区别

- 当配置文件不存在时，写入操作执行的结果

  - `One`：写入操作时，自动创建配置文件（目录必须存在）
  - `Two`：写入操作时，触发写入失败异常，只能使用`As`方法

  ```go
  viper.WriteConfig()		
  viper.WriteConfigAs("./config/settings.yaml")	
  ```

- 查找配置文件的方式
  - `One`：根据指定的文件全路径名来查找配置文件
  - `Two`：根据添加的搜索路径，依次查找配置文件

**从官方文档看，作者推荐采用`Two`的方式**

#### 从配置文件获取配置项

调用`ReadInConfig()`方法，从配置文件中读取配置项

```go
if err := viper.ReadInConfig(); err != nil {
	fmt.Printf("读取配置文件失败：%s。稍后进行初始化...\n", err)
    ...
}
```

- 根据配置文件的类型，自动识别文件格式
- 将配置项保存到`map[string]interface{}`对象中
- 结构体中的`Key`名，采用`Prefix.Key`的方式级联

#### 将配置项写入配置文件

将配置项写入配置文件，可以使用两种写入方式

- 直接覆盖源文件
- 另存为新的配置文件（也可以与源文件同名）

```go
//if err := viper.WriteConfig(); err != nil {
if err := viper.WriteConfigAs("./config/hello.yaml"); err != nil {
	fmt.Printf("写配置文件hello.yaml失败：%s\n", err)
}
```
### 环境变量

环境变量的优先级高于配置文件。也就是说：如果同时从配置文件和环境变量中读取到相同的配置项，则从环境变量中读取的配置项被应用，从配置文件中读取到的配置项被丢弃

要想从系统的环境变量中读取配置信息，需要进行配置项的绑定，这个操作一般会放在模块的`init()`函数中进行

```go
func init() {
    viper.AutomaticEnv()	// 将环境变量全部绑定为配置项
    // 手动绑定环境变量
    viper.BindEnv("redis.port") 
    viper.BindEnv("go.path", "GOPATH") // 将环境 GOPATH 绑定为 go.path 的配置项
}
```

- ` viper.AutomaticEnv()`：将所有的环境变量全部绑定为同名的配置项
- `viper.BindEnv(key)`：将名为`key`的环境变量绑定为同名的配置项
- `viper.BindEnv(key, envkey)`：将名为`envkey`的环境变量绑定为`key`的配置项

### 命令行

命令行的优先级是最高的

`viper`使用`pflag`库解析命令行参数，需要在`init()`方法中指定绑定的命令行参数，在`main()`入口中调用解析命令

```go
func init() {
    pflag.Int("port", 1001, "端口号")	// 注意 port 是大小写敏感的
	viper.BindPFlags(pflag.CommandLine)
}

func main() {
    pflag.Parse()
    ...
}
```

在运行程序时，可以在命令行添加参数，强制应用该配置项

```bash
$ app --port 8080
```

### 配置项名称

### 获取配置项

无论采用哪种存储/获取配置项的方式，最终都是将配置项读取到内存中，保存到`map[string]interface{}`类型的变量中

一旦完成了配置项的获取（读取到内存中），我们就可以使用`GetXXX`系列方法来读取配置项

```go
fmt.Println("Read Port:", viper.Get("Port"))
fmt.Println("db.username:", viper.Get("db.username"))
fmt.Println("db.password:", viper.GetString("db.password"))
```

#### 配置项名

配置项的名称采用`.`级联方式，类似于面向对象中访问属性/方法的`.`操作符

```yaml
db:
  Name: HelloDB
  PassWord: root
  UserName: root
  dbType: mySql
```

上面的配置文件中，`db`有四个配置项，访问这些配置项时，使用`db.`前缀

```go
fmt.Println("db.password:", viper.GetString("db.password"))
```



### 设置配置项

### 监听修改

### 远程服务

### 



