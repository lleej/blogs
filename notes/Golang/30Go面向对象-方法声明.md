title: 30.Go面向对象之方法声明
date: 2020-04-29
tags: Go
categories: Go语言
layout: post

------

摘要：本节介绍`Go`语言的面向对象中的方法声明

<!-- more -->

## 方法

`Go`语言没有与其他语言一样清晰的`OOP`定义，使用方法这种特殊的函数，和特殊类型建立关联。与`OOP`中的方法同义

### 方法声明

在函数声明时，函数名前附加一个参数，即是**方法声明**

这个附加的参数会将该函数附加到这种类型上，相当于为这种类型定义了一个独占的方法

```go
func (variable typename) name(parameter-list) (result-list) {
    body
}
```

我们来看一个例子：

```go
package geometry

import "math"

type Point struct{ X, Y float64 }

// 传统的函数表达
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// 类型Point的方法
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

这个附加的参数`p`，称为方法的接收器(`receiver`)，与面向对象语言中的`this`或`self`同义，但可以任意指定名称。一般情况下，这个参数的名字用类型的第一个小写字母表示。本例中类型为`Point`，参数名为`p`

### 方法调用

方法的调用使用`.`操作符，也称为**选择器**，语法上同`struct`类型中的成员访问一样

在方法中，可以直接使用接收器这个参数值，类似于`self`缺省是方法的第一个参数一样

```go
p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // "5", function call
fmt.Println(p.Distance(q))  // "5", method call
```

### 命名空间

虽然本例中有两个函数的名称都是`Distance`，但并不冲突：

- 第一个是包级的函数
- 第二个是类型的方法

注意：方法和成员使用相同的命名空间，因此不能重名

```go
func (p Point) X() { // type Point has both field and method named X
  ...
}
```

### 挂载方法

不同类型可以有相同方法名，在执行时会根据接收器来确定调用哪个类型的方法

我们可以给同一个包内任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者接口

注意：不能给内置类型挂载方法

### 指针对象的方法

当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了

```go
func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
```

注意：指针对象的方法与类型方法两者公用相同的命名空间，也就是说下面的例子是不能编译的

```go
func (p Point) ScaleBy(factor float64) { 
    p.X *= factor
    p.Y *= factor
}

func (p *Point) ScaleBy(factor float64) { 
    p.X *= factor
    p.Y *= factor
}
// method redeclared: Point.Distance
//	method(Point) func(Point) float64
//	method(*Point) func(Point) float64
```

