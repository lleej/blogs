title: 03.Go语言学习笔记-Go变量声明
date: 2020-04-07
tags: Go
categories: Go语言
layout: post

------

摘要：本节介绍`Go`语言的变量声明

<!-- more -->

## 声明

`Go`语言中的标识符（包括：变量、常量、类型、函数等），在使用前必须进行声明

## 变量

> 顾名思义：变量就是在程序中可以改变其值的标识符

### 声明用法

`Go`语言有多种定义变量的用法，声明语句是`var`

#### 标准用法

```go
var 变量名 变量类型 = 表达式
```

其中，变量类型和表达式可以省略其中的一个

- 省略变量类型，则根据表达式推导出变量类型
- 省略表达式，则用零值初始化变量
  - 数值类型（整数、浮点数）：`0`
  - 布尔类型：`false`
  - 字符串类型：`""`
  - 接口或引用类型：`nil`

```go
var a int
var b = '10' 
fmt.Printf(a) //输出 0，初始化为零值
fmt.Printf("%T", b) //输出 string，根据表达式进行类型推导
```

#### 批量格式

可以在一个声明语句同时声明多个变量，有三种声明方式可以使用

**一行同一类型**

```go
var 变量1, 变量2, 变量3 变量类型
```

使用`,`分隔变量名

```go
var a, b, c int //变量a, b, c 都是 int 类型
```

**一行不同类型**

```go
var 变量1, 变量2, 变量3 = 表达式1, 表达式2, 表达式3
```

使用类型推导，可以在一个变量声明语句中声明不同类型的变量

```go
var a, b, c = 1, false, "2"
```

**多行多类型**

将变量声明组合在一起，因为在没有`go`文件中都会声明大量的变量，因此推荐使用

```go
var (
	变量1 变量类型 = 表达式
  变量2 变量类型 = 表达式
  ...
)
```

简化了多变量声明的书写格式，也便于查看和维护

```go
var (
	a, b    int
	d, e, f string
	g       = 1.0
)
```

#### 短变量

在函数内部，可以使用简洁的`变量名 := 表达式`方式声明并初始化变量

```go
func hello() {
  a := 10
  b := 'abc'
}
```

注：使用短变量声明时，必须至少声明一个新的变量

```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) //编译错误，没有声明新变量
```

#### 匿名变量

定义变量的占位符，主要用于多重赋值时，想要忽略某个值。匿名变量不占用命名空间，不分配内存，可以重复使用

```go
func hello() {
  x, _ := foo()
  _, y := foo()
}
```

### 变量初始化

- 包级声明的变量在`main`入口函数执行前完成初始化
- 局部变量在声明语句被执行时完成初始化

注：如果包级声明的变量是通过调用一个函数的表达式初始化，则该函数会在`main`入口函数执行前被调用

### New函数

声明变量的另一种方法是使用内置的`new`函数，返回该类型变量的指针

```go
变量名 = new(变量类型)
```

可以在`var`或短变量声明中使用`new(T)`函数，其用法与变量声明语句没有任何区别，**类似是一种语法糖**

```go
var (
  y 		 float64
	z      = new(float64)
)

func main() {
  tmp = &y
	fmt.Printf("tmp变量的类型: %T\t%v.", tmp, *tmp) //输出 *float64	0
  fmt.Printf("z变量的类型: %T\t%v.", z, *z) //输出 *float64	0
}
```

由于`new`只是一个预定义的函数，并不是关键字，因此我们可以将`new`名字重新定义为别的类型

```Go
func delta(old, new int) int { return new - old }
```

由于`new`被定义为`int`类型的变量名，因此在`delta`函数内部是无法使用内置的`new`函数的

**两种声明指针类型变量的区别**

使用变量声明语句也可以直接声明指针类型，与`new(T)`声明的变量在使用上有本质的区别，需要格外注意

```go
var (
  y 		 *float64 //直接声明为指针类型变量
  z      = new(float64) //使用new()函数创建指针类型变量
)

func main() {
	fmt.Printf("a变量的类型: %T\t%v.", y, *y) //invalid memory address or nil pointer dereference
  fmt.Printf("a变量的类型: %T\t%v.", z, *z) //输出 *float64	0
  tmp := 0.0
  y = &tmp
	fmt.Printf("a变量的类型: %T\t%v.", y, *y) //输出 *float64	0
}
```

注：直接声明为指针类型的变量`y`，其值为`nil`。也就是说该变量没有指向任何内存地址，当访问其地址时就会出错。而且，指针类型变量不能直接赋值，必须通过指向一个变量的地址来赋值`y = &tmp`

### 生命周期

总的来说，就是全局生命周期和局部生命周期两大类

- 全局声明周期

  包级变量，生命周期和整个程序的运行周期是一致的

- 局部生命周期

  局部变量，生命周期则是动态的

  - 每次从创建一个新变量的声明语句开始
  - 直到该变量不再被引用为止
  - 然后变量的存储空间可能被回收
  - 函数的参数变量和返回值变量都是局部变量，在函数每次被调用的时候创建

`Go`的**垃圾回收**机制就利用了生命周期的变量可达特性，即通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果，意味着可以被**垃圾回收**

但如果将局部变量的指针保存到全局生命周期的对象中（称为：**变量逃逸**），将会阻止对局部生命周期对象的**垃圾回收**，从而可能影响程序的性能

```Go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}
```

## 赋值

使用赋值语句可以更新一个变量的值，`变量名 = 表达式`

```go
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
```

**二元运算符**

```go
count[x] *= scale // 省去对变量表达式的重复计算
```

**自增自减**

```go
v := 1
v++    // 等价方式 v = v + 1；v 变成 2
v--    // 等价方式 v = v - 1；v 变成 1
```

### 元组赋值

允许同时更新多个变量的值，常用于交换变量值，或者函数返回多个值的情况。与`Python`类似的用法

**交换变量值**

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

不需要中间变量，可以直接进行交换

```Go
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x
}
```

可以简化代码，可读性和性能更好。但如果表达式太复杂的话，应该避免使用元组赋值（可读性和调试更复杂）

## 可赋值性

程序中很多地方会发生隐式的赋值行为

- 函数调用会隐式地将调用参数的值赋值给函数的参数变量
- 函数返回语句会隐式地将返回操作的值赋值给结果变量
- 复合类型的字面量会产生赋值行为

```go
medals := []string{"gold", "silver", "bronze"}
```

可赋值性：不管是**隐式**还是**显式**地赋值，赋值语句左边的变量和右边最终求到的值必须有**相同的数据类型**

对于两个值是否可以用`==`或`!=`进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的

