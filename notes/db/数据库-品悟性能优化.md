title: 数据库-性能优化
date: 2019-02-18
tags: 优化
categories: 数据库
layout: post

------

摘要：本文章介绍常用的数据库开发规范。

原文作者：张建中

<!--more-->

## OLTP和OLAP的特性

> OLTP：联机事务处理
>
> OLAP：决策支持系统，又叫DSS

![1550192712764](/Users/lijie/Work/blogs/notes/db/assets/%E5%93%81%E6%80%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%960001.png)

## 执行计划统计信息资源计算

![1550193474960](/Users/lijie/Work/blogs/notes/db/assets/%E5%93%81%E6%80%A7%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%960002.png)

```mysql
内存消耗：13723585*8192=104GB
磁盘I/O消耗：2*8192=16KB
```

## 清空缓冲区

```mssql
清空数据缓冲区：alter system flush buffer_cache;
清空共享池缓冲区：alter system flush shared_pool;
```

## 配合使用SQL*Trace和TKPROF

```mysql
<!--跟踪当前会话-->
alter session set sql_trace=true;
execute sql;
alter session set sql_trace=false;

<!--跟踪其他会话-->
exec dbms_system.set_sql_trace_in_session(sid,serial#,true);
execute sql;
exec dbms_system.set_sql_trace_in_session(sid,serial#,false);

<!--生成跟踪文件-->
tkprof  tracefile outputfile [options]
```

## B*树单字段索引设计建议

> (1)分析SQL语句中的约束条件字段
> (2)如果约束条件字段不固定，建议创建针对单字段的普通B*树索引
> (3)选择可选择性最高的字段建立索引
> (4)如果是多表连接SQL语句，注意被驱动表的连接字段是否需要创建索引
> (5)通过SQL分析工具，分析执行计划并以量化形式评估效果

## 开发规范一：尽量不要将字段嵌入到表达式之中

**案例1**，如下语句片段：

```mysql
to_char(DJ_SZ.JDRQ,'YYYY.MM.DD') BETWEEN '2019.01.01' AND '2019.01.03'
即使在DJ_SZ.JDRQ建了索引，该索引仍然无法启动，依然会使用全表扫描。因为索引树中记录的是DJ_SZ.JDRQ的值，而不是
to_char(DJ_SZ.JDRQ,'YYYY.MM.DD')函数值。上述语句片段应该修改成：
DJ_SZ.JDRQ BETWEEN to_date('2019.01.01','YYYY.MM.DD') AND to_date('2019.01.03','YYYY.MM.DD')
```

**案例2**，如下语句片段：

```mysql
and (sysdate-to_date(a.efftt,'yyyymmddhh24miss'))*24*60<=15
该语句的意思是查询最新15分钟之内的数据。上述语句片段应该修改成：
a.efftt>=to_char((sysdate-1/96),'yyyymmddhh24miss')
```

## 开发规范二：慎用自定义函数

**案例**，如下语句：

```mysql
SELECT A.GRID,A.BXH,DP_YLZF.FFDD2FFXS(FFDD) FFXS FROM GR_XX A,GR_YLZF_Y B
WHERE A.GRID=B.GRID AND DP_YLZF.FFDD2FFXS(FFDD)=:b3 AND ZFBZ='1'
AND DP_DW_QUERY.GET_ZFQXYL(A.DWID):=b4;
通过自定义函数FFDD2FFXS、GET_ZFQXYL去读取相关表的字段，自定义函数也是函数，即使在FFDD和DWID字段上建了索引，Oracle也不会用。所以，需要将语句中的函数DP_YLZF.FFDD2FFXS(FFDD)、DP_DW_QUERY.GET_ZFQXYL(A.DWID)修改为直接对相关表的操作。
```

## 开发规范三：谨慎使用函数索引

**案例**，如下语句片段：

```mysql
to_char(DJ_SZ.JDRQ,'YYYY.MM.DD') BETWEEN '2019.01.01' AND '2019.01.03'
为什么不使用函数索引？例如：
create index ind_1 on DJ_SZ(to_char(JDRQ,'YYYY.MM.DD'));
原因如下：
(1)函数索引维护(插、删、改操作)成本高于普通索引
(2)函数索引的计算值可能大于原字段值，消耗更多的索引存储空间
(3)日期值尽量使用日期字段，能更好使用更多的日期函数
```

## 开发规范四：复合索引

**案例**，如果在员工表(emp)的(ENAME,JOB,MGR)3个字段创建了索引，然后，写如下查询语句，索引是否使用？

```mysql
select * from emp where ENAME='a' and JOB='b' and MGR=3;
select * from emp where JOB='b' and MGR=3 and ENAME='a';
select * from emp where JOB='b' and ENAME='a' and MGR=3;
select * from emp where JOB='b' and MGR=3;
select * from emp where ENAME='a' and MGR=3;
select * from emp where ENAME='a';
select * from emp where JOB='b';
select * from emp where MGR=3; 
```

**答案**，上述语句中只要有ENAME='a'条件，就用上索引。

**复合索引两大特性**：前缀性和可选择性

> 例子：用省、市、县存储数据，建立复合索引时，索引顺序应该是(县、市、省)
>
> 前缀性：查询条件中只要出现复合索引中第一个字段的，就会使用索引
>
> 可选择性：字段值多的排在前面

**跳跃扫描索引**：当复合索引中第一个字段可选择性少时，查询条件中没有第一个字段，也可以使用索引

例子：复合索引(GENDER,ENAME,JOB,MGR)，GENDER只有男和女，这样的复合索引设计也违背了复合索引的可选择性。

## 复合索引设计建议

> (1)分析SQL语句中的约束条件字段
> (2)如果约束条件字段比较固定，则优先考虑创建针对多字段的普通B*树复合索引
> (3)如果单个字段是主键或唯一字段，或者可选择性非常高的字段，尽管约束条件字段比较固定，也不一定要建立复合索引，可建立单字段索引，降低复合索引的开销
> (4)在复合索引设计中，需首选考虑复合索引的前缀性。即在SQL语句中，只有将复合索引的第一个字段作为约束条件，该复合索引才会启用
> (5)在复合索引设计中，其次应考虑复合索引的可选择性，即按可选择性高低，进行复合索引字段的排序
> (6)如果条件涉及的字段不固定，组合比较灵活，则在多个字段单独创建索引
> (7)如果是多表连接，注意是否可以在被驱动表的连接字段与该表的其他约束条件字段上创建复合索引
> (8)通过SQL分析工具，分析执行计划并以量化形式评估效果

## 索引监控：监控索引是否被使用

```mysql
开户监控：alter index <索引名> monitoring usage;
查询索引是否被使用：select * from v$object_usage;
关闭监控：alter index <索引名> nomonitoring usage;
```

## 索引碎片分析和整理

```mysql
执行如下语句可检测索引的碎片情况：
analyze index <索引名> validate structure online;
select name,del_lf_rows_len,lf_rows_len,(del_lf_rows_len/lf_rows_len)*100 fragratio from index_stats;
其中索引碎片率(%)=(del_lf_rows_len/lf_rows_len)*100
如果索引碎片率超过20%，则碎片已经很严重。

索引碎片整理
重建索引:alter index <索引名> rebuild online nologging;
压缩索引:alter index <索引名> coalesce;
```

## 多表连接总体思路

> 首先判断是OLTP应用还是OLAP应用
> 如果是OLTP应用，则优化思路是由小到大，即从限制性最强，返回记录最小的连接开始，基本采用嵌套循环连接技术，依次完成其他表的连接，并在访问每张表时，合理使用索引，特别是复合索引。
> 如果是OLAP应用，则优化思路基本是HASH加并行处理，表连接顺序不是最主要的。

## OLTP应用的表连接优化

> (1)尽量将限制性最强的表作为驱动表。当然，驱动表上的限制性条件字段上应该有索引，包括主键、唯一索引或其他索引、复合索引。
> (2)考虑如下原则：在每次连接操作之后尽量保证返回记录数最少，传递给下一个连接操作。
> (3每次连接操作基本采用嵌套循环连接技术。
> (4)尽量通过在被驱动表的连接字段上索引，访问被驱动表。
> (5)如果被驱动表上还有其他限制性条件，可以创建合适的复合索引。
> (6)全表扫描也许是合理的。例如小表、代码表。
> (7)依次类推，顺序完成所有表的连接操作。

## 如何使用子查询

> 建议不使用子查询，原因如下：
> (1)子查询在大部分情况下，原理上等同于多表连接操作。
> (2)子查询导致SQL语句冗长，可读性下降。
> (3)子查询方式可能强制Oracle优化器选择错误的执行路径，导致整个语句的性能下降，这点最重要。

## 到底是使用in还是exists

**in和exists的原理**

> in操作的原理是先进行子查询操作，再进行主查询操作。
> exists操作的原理是先进行主查询的操作，再到子查询中进行过滤。

**使用建议**

> (1)如果限制性强的条件在子查询，则使用in操作
> (2)如果限制性强的条件在主查询，则使用exists操作

## 开发规范五：索引连接字段的数据类型要一致

> 当多表连接时，表之间的字段的数据类型一定要一致，否则查询不会使用索引

## 观察执行计划是否有迪卡儿乘积

> 当执行计划中出现:MERGE JOIN CHARTESIAN，即合并连接迪卡儿乘积。

## 分区交换技术(exchange)：速度快

**案例**，当需要将当前表的数据导入到历史表，并删除当前表的记录时，可以考虑分区交换技术：

> (1)凡是在一个分区大表中，需要对一个分区数据单独进行某种批处理时，最好的办法是将这个分区数据交换到外面一张普通表，在普通表完成处理之后，再交换回原来的分区表。
> (2)分区交换技术不仅可用于分区表与普通表之间的数据交换，也可用于复合分区与普通表之间的数据交换，前提是复合分区的二维分区与普通表的分区表是一致的。

## 如何在生产系统实施分区

**传统方式**

> (1)业务停顿
> (2)create table <新分区表名> partition by ... as select * from <非分区表名或原分区表>
> (3)rename  <新分区表名> to <原表名>
> (4)恢复业务

**在线重定义的方式**

> 通过调用Oracle包实现业务不停顿，相关步骤查询官方文档

## 数据仓库技术指导

> (1)大批量、并行处理思路
> (2)合理运用Oracle并行处理、分区操作、HASH-JOIN、MERGE语句、数据仓库函数、外部表、位图索引、星形查询、Multi-Insert、系统级临时表、物化视图和语句重写、传输表空间等典型技术
> (3)合理设计计算架构，尽量在数据库内部完成海量数据处理

**并行处理**:并行度个数=CPU个数*4

```mysql
alter session enable parallel dml;
insert /*+ append parallel(d,12) */ into <表名> d nologging
select ....
```

**数据仓库主要计算函数**

```mysql
(1)ROLLUP&CUBE:多维汇总函数
(2)Sampling:抽样函数
(3)Rank:排名函数，如果rank，percentile,ntile,top,bottom
(4)Moving Window:计算累计值和动态值，如avg,sum,variance,stddev,firstvalue
(5)Period-over-period comparisons:比较函数
(6)Ratio-to-report:比率计算函数
(7)LAG/LEAD functions:按时间进行记录值的比较
(8)Statistics functions：协方差、线性回归等统计函数，如convariance,correlation,linear regression
```