title: 02.复杂度分析
date: 2020-05-07
tags: 数据结构
categories: 数据结构
layout: post

------

摘要：数据结构和算法是`IT`领域的底层基础，尤其是对从事软件开发的码农来说，学好数据结构和算法打下一个非常扎实的基础，未来才能够承载你在此基础上建造高楼大厦。系列文章是王争《数据结构与算法之美》的学习笔记...

<!-- more -->

## 知识点

### 等比数列

等比数列是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列，常用G、P表示。这个常数叫做等比数列的公比，公比通常用字母q表示(q≠0)，等比数列a1≠ 0。其中{an}中的每一项均不为0。注：q=1 时，an为常数列

## 是什么

复杂度分析：从**执行效率（时间）**和**资源消耗（空间）**两个维度对数据结构和算法的性能进行评估的统称

从评估维度划分为：

- 渐进**时间复杂度**（asymptotic time complexity）：**执行时间**随数据规模增长的变化趋势
- 渐进**空间复杂度**（asymptotic space complexity）：**存储空间**随数据规模增长的变化趋势

从评估阶段划分为：

- 事后统计法

  - 真实性：使用测试工具进行性能测试，得出的真实结果

  - 局限性：依赖测试环境和数据规模，两者可能导致测试结果截然相反

- 事前统计法

  - 真实性：是在设计和编码阶段（执行前）进行的粗略评估
  - 局限性：通过评估结果的高/低阶可以进行直接比较，但**不作为定性结果**

渐进复杂度分析是一种事先进行的粗略评估，用于在设计和开发阶段快速的分析代码的性能，提升代码的开发效率和质量的一种手段。但它不能对性能进行定性判定，还需要在运行环境和数据集下进行性能测试，来最终验证

## 为什么

复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点

- 通过代码`review`就可以了解其性能指标
- 性能评估可以始终贯穿整个研发阶段

培养良好的思维模式和编码习惯，能编写出性能更优的代码

- 减少持续优化迭代的成本，提高开发效率
- 更好的适应运行环境和数据量的变化，高性能有助于降低维护成本

## 怎么做

以时间复杂度分析为例进行说明，一段代码的时间复杂度可以用其执行时间表示

**执行时间 = Ʃ(每行代码执行时间 * 每行代码执行次数)**

我们假设每行代码的执行时间都相同，均为`unit_time`，则**执行时间与代码总执行次数成正比**

```go
func cal(n int) int {
	sum := 0
	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
      t := i * j
			sum = sum + t
		}
	}
	return sum
}
```

上例中`cal`函数的执行时间为：`unit_time * (1 + n + 3n`^2^ `+ 1)`

### 大O表示法

我们可以用一个公式来表示上例中的复杂度分析结果，该公式也可以应用于空间复杂度分析

```go
T(n) = O(f(n))
```

- `n`：数据规模
- `T(n)`：执行时间
- `f(n)`：执行次数
- `O`：`T(n)`与`f(n)`成正比关系

用大O表示法对上例中的复杂度进行说明：`T(n) = O( 2 + n + 3n`^2^ `)`

假设`n`的值非常大，公式的结果由最大量级(3n^2^)确定，而低阶(`n`)、常量(`2`)和系数(`3`)并不能左右增长趋势，可以将这些忽略掉。简化后的公式：`T(n) = O( n`^2^ `)`

### 时间复杂度分析

一般情况下，时间复杂度分析的方法可以归纳为以下三种

- 一段代码，看最多的循环执行次数

  只关注最多的执行次数，忽略常量（即使是循环）、低阶和系数

- 加法原则：多段代码，看量级最大的代码的复杂度

  多段代码：`T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))`

  示例：`T(n) = max(O(n) + O(1)) = O(n)`

- 乘法原则：嵌套代码，看嵌套内外代码复杂度的乘积

  嵌套代码：`T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))`

  示例：`T(n) = O(n) * O(n) = O(n`^2^ `)`

### 复杂度量级

![复杂度量级](./assets/3723793cc5c810e9d5b06bc95325bf0a.jpg)

如图所示，通常将复杂度量级分为`7`种，便于归类和比较

- 常量阶：`O(1)`。没有循环、递归语句
- 对数阶：`O(logn)`。常见于：归并排序、快速排序等
- 线性阶：`O(n)`。循环、递归等
- 线性对数阶：`O(nlogn)`
- 次方阶：`O(n`^k^ `)`。平方阶、立方阶等
- 指数阶：`O(2`^n^ `)`
- 阶乘阶：`O(n!)`

以上罗列的复杂度量级，可以粗略地分为两类：多项式量级和非多项式量级

- 多项式量级：常量阶、对数阶、线性阶、线性对数阶、次方阶
  - 常用的量阶
- 非多项式量级：指数阶和阶乘阶
  - 非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题
  - 当数据规模 n 越大，算法的执行时间会急剧增加，求解问题的执行时间会无限增长，是非常低效的算法

**复杂度越高阶，执行效率越低**

从低阶到高阶排序：`O(1)、O(logn)、O(n)、O(nlogn)、O(n2)`

![复杂度排序](./assets/497a3f120b7debee07dc0d03984faf04.jpg)

### 不易判定的几种

**常量阶**

```go
func cal(n int) int {
	sum := 0
	for i := 1; i <= 1000; i++ {
		sum = sum + i
	}
	return sum
}
```

虽然`cal`函数中有一个循环语句，但循环执行次数为常量`1000`，因此该函数的复杂度仍然是常量阶`O(1)`

**对数阶**

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度

```go
func cal(n int) int {
	sum := 0
	for i := 1; i < n; i++ {
		sum += i
		i *= 2
	}
	return sum
}
```

虽然`cal`函数中有一个循环语句，但每次循环，循环变量的值乘以`2`，就是下图所示的等比数列

![等比数列](./assets/9b1c88264e7a1a20b5954be9bc4bec9a.jpg)

通过 2^x^=n 求解 x ，也就是`x=log2n`。实际上，不管是以 `2`、`3`还是`10` 为底，所有对数阶都记为 `O(logn)`

原因：对数之间是可以互相转换的，`log3n = log32 * log2n`，而`log32`是一个常量，可以忽略该系数。`O(log2n)` 就等于`O(log3n)`，在对数阶时间复杂度的表示方法里，我们忽略对数的**底**，统一表示为`O(logn)`

**两个数据规模确定**

```go
func cal(m, n int) int {
	sum1, sum2 := 0, 0
	for i := 1; i < m; i++ {
		sum1 += i
	}
	for i := 1; i < n; i++ {
		sum2 += i
	}
	return sum1 + sum2
}
```

当无法确定`m`和`n`两个数据规模谁的量级大时，就不能简单地利用加法法则，省略掉其中一个，而是采用`O(m+n)`表示

### 空间复杂度分析

我们常见的空间复杂度就是`O(1)、O(n)、O(n2)`，像`O(logn)、O(nlogn)`这样的对数阶复杂度平时都用不到

而且，空间复杂度分析比时间复杂度分析要简单很多

```go
func print(n int) {
	var a []int = make([]int, n)
	for i := 0; i < n; i++ {
		a[i] = i * i
	}
	for i := n - 1; i >= 0; i-- {
		fmt.Println(a[i])
	}
}
```

与时间复杂度分析类似，空间复杂度分析看代码中变量分配的空间大小

- 变量`a`：分配了`n`个整数空间
- 变量`i`：分配了`1`个整数空间

因此，函数`cal`的空间复杂度为：`O(n)`

## 四个概念

我们掌握了时间复杂度和空间复杂度的分析方法（大O表示法），可以通过阅读一段代码得出分析结果。但是，实际的代码并不像示例中那样简单，有可能存在：同一段代码，不同输入时，复杂度量级不一样，这种不确定的情况

这时，就需要了解四个新概念：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。可以帮助我们更加全面地表示一段代码的执行效率

本例是一个从数组中查找数据并返回其下标的函数

```go
// n表示数组array的长度
// x表示要查找的元素值
// 返回x在数组中的下标，没找到返回-1
func find(array []int, n, x int) int {
	pos := -1
	for i := 0; i < n; i++ {
		if array[i] == x {
			return i
		}
	}
	return pos
}
```

我们看到，循环执行的次数不是固定不变的，而是由`x`在数组中的位置决定的

- 第一个位置，则`O(1)`
- 不存在`x`，则`O(n)`

### 最好情况时间复杂度

最好情况时间复杂度（`best case time complexity`）：在最理想的情况下，代码执行的时间复杂度

上面的例子中，最好情况时间复杂度为：`O(1)`

### 最坏情况时间复杂度

最坏情况时间复杂度（`worst case time complexity`）：在最糟糕的情况下，代码执行的时间复杂度

上面的例子中，最坏情况时间复杂度为：`O(n)`

### 平均情况时间复杂度

平均情况时间复杂度（`average case time complexity`）：在所有情况下，执行次数的加权平均值。也称为**加权平均时间复杂度**或者**期望时间复杂度**

计算公式有两种：

- 不考虑每种情况发生的概率

  对示例代码计算平均时间复杂度的算法如下，使用大O表示法：`O(n)`

  ![img](./assets/d889a358b8eccc5bbb90fc16e327a22f.jpg)

- 考虑每种情况发生的概率

  对示例代码计算平均时间复杂度的算法如下，使用大O表示法：`O(n)`

  ![img](./assets/36c0aabdac69032f8a43368f5e90c67f.jpg)

### 均摊时间复杂度

均摊时间复杂度（`amortized time complexity`）：通过**摊还分析**得到的时间复杂度

```go
// array表示一个长度为n的数组
// 代码中的len(arr)就等于n
var n int = 100
var arr []int = make([]int, n)
var count int = 0
func insert(val int) {
	if count == len(arr) {
		sum := 0
		for i := 0; i < len(arr); i++ {
			sum += arr[i]
		}
		arr[0] = sum
		count = 1
	}
	arr[count] = val
	count++
}
```

- 最好情况时间复杂度：`O(1)`

- 最坏情况时间复杂度：`O(n)`

- 平均时间复杂度：`O(1)`

  ![img](./assets/6df62366a60336d9de3bc34f488d8bed.jpg)

**摊还分析**：在对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。

- 绝大多数情况下是低级别复杂度，极少数情况是高级别复杂度
- 低级别和高级别复杂度出现具有时序规律（上例中：一个`O(n)`后，紧跟`n-1`个`O(1)`，循环往复）
- 均摊时间复杂度一般等于最好情况时间复杂度

与平均时间复杂度的区别：可以认为均摊时间复杂度就是一种**特殊**的平均时间复杂度

### 使用场景

当同一段代码，在不同输入的情况下，时间复杂度有量级的差距时，才会使用这四种复杂度表示法，帮助我们更加全面地表示一段代码的执行效率

均摊时间复杂度和平均时间复杂度都是计算平均值，但两者适用的场景稍有不同。如果一段代码符合**摊还分析**的两个要点（低量级为主、高量级为辅，两者出现具有时序规律）时，建议使用均摊时间复杂度表示均值

## 课后作业

分析下面一段代码的时间复杂度

```go
// 全局变量，大小为10的数组arr，长度len，下标i
var i = 0
var len = 10
var arr []int = make([]int, len)

// 往数组中添加一个元素
func add(element int) {
	if i >= len { // 数组空间不够了
		// 重新申请一个2倍大小的数组空间
		var newArr = make([]int, len*2)
		// 把原来array数组中的数据依次copy到new_array
		for j := 0; j < len; j++ {
			newArr[j] = arr[j]
		}
		// new_array复制给array，array现在大小就是2倍len了
		arr = newArr
		len = 2 * len
	}
	// 将element放到下标为i的位置，下标i加一
	arr[i] = element
	i++
}
```

### 回答

1. 因为随着输入的不同，会有不同的时间复杂度量级，因此这段代码应该使用三个时间复杂度进行度量
2. 最好情况时间复杂度：`O(1)`。当前数组`arr`还有空间时；属于绝大多数情况
3. 最坏情况时间复杂度：`O(n)`。当前数组`arr`没有空间时；属于极少情况
4. 均摊时间复杂度：`O(1)`。具备摊还分析的要素：低量级为主、高量级为辅，两者具有时序规律

