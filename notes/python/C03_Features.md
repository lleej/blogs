# 高级特性
## 切片
1. 主要用于字符串的处理，不同编译器/解释器都有针对的语法
2. Python提供了一个统一的语法，支持多种(list/tuple/string)有下标数据类型的切片操作
3. 语法: 变量名[起始位置:结束位置:间隔]
    - 起始位置: 第一个位置为0，最后一个位置为-1
    - 结束位置: 不包括该位置，如结束位置为3，则不包括3
    - 间隔: 每几个提取一个
#### 总结
1. Python中的切片语法`[start:stop:inteval]`非常简单和灵活，适用于多种类型变量

## 迭代
1. 用于遍历可迭代对象(如: list、tuple、string、dict)
2. 支持有下标对象(list)以及无下标对象(dict)
3. 语法: for ... in 
    - 例如: for li in ['1', '2', '3', '4']
    - 支持多个for 变量 for x, y in [(1, 2), (2, 4), 3, 9)]
4. 使用collections模块的Iterable类型，可以判断对象是否是可迭代对象
5. 使用enumerate函数，可以把List变成索引-元素对，类似于有下标的数组
#### 总结
1. 判断是否是`Iterable`类型
2. `for`语法遍历，支持多级、条件，语法简单易懂
3. `enumerate`函数可以提供下标，适用于需要的地方

## 列表生成式
1. List Comprehensions, 是Python内置的非常简单却强大的可以用来创建List的生成式
2. 通过range函数生成
3. 通过表达式生成
    - for 表达式
    - 两层 for 表达式
    - 带条件的 for 表达式
    - 多变量的 for 表达式
#### 总结
1. `range()`函数很强大
2. 表达式生成语法简单，但功能强大

## 生成器
1. 生成器`generator`存储的是某种算法，在循环过程中推算出后续的元素，本身不存储。
2. 因此可以用来存储庞大的数据列表，如全体自然数，这个是列表生成式所不具备的
3. 调用`next(x)`时，生成结果；如果超过了范围，抛出`StopIteration`错误
4. 生成器可以使用`for`来循环调用，因此也是迭代对象
5. 使用`()`替代`[]`列表生成式，或者在函数中使用`yield x`，就可以生成一个生成器对象
#### 总结
1. 是一个对象
2. 内存占用少
3. `yield g`语法简单，功能强大

## 迭代器
1. 可直接作用与`for`循环的的对象统称为 **可迭代对象**`Iterator`
    - 集合类型，如: `list tuple dict set str`等
    - 生成器`generator`，包括: 生成器和带`yield`的`generator function`
2. 可以使用`isinstance()`判断一个对象是否是`Iterable`对象
3. **迭代器**`Iterator` : 可以被`next()`函数调用并不断返回下一个值的对象
4. 使用`iter()`函数，可以将`Iterable`对象转变为`Iterator`对象
5. `Iterator`对象是一个数据流，可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。它是一个有序序列，但不能提前预知序列的长度，所以`Iterator`的计算是惰性的
6. `Iterator`甚至可以表示一个无限大的数据流，例如: 全体自然数
#### 总结
1. 不是`Iterable`
2. 支持`next(g)`函数
3. 与生成器可以看做一体

