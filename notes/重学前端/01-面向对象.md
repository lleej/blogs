title: 01.Javascript的面向对象
date: 2019-04-03
tags: Javascripit
categories: 前端
layout: post

------

摘要：文本是使用Git进行代码管理的第六篇文章，重点介绍：适合团队自身的开发流程和开发规范以及版本库的操作。

<!-- more -->

# Javascript中任务的执行

## 宏观任务

由宿主发起的任务称为宏观任务。也就是我们的代码、浏览器API等

## 微观任务

由Javascript引擎发起的任务。例如：Promise

## 任务队列

不管是宏观任务还是微观任务，都是放到任务队列中执行的。

一个宏观任务会包含一个微观队列。因此，对于任务执行的顺序：宏观任务—>宏观任务中的微观任务—>下一个宏观任务

所以，对于异步操作`promise`和`setTimeout`来说，`promise`会先于`setTimeout`执行。

## promise

Promise 是 JavaScript 语言提供的一种标准化的异步管理方式。它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。

如下示例所示，因为`c`是异步任务，其会添加到当前宏观任务的尾部。因此，它不会先于`b`执行

```javascript
var r = new Promise(function(resolve, reject){
    console.log("a");
    resolve()
});
r.then(() => console.log("c"));
console.log("b")
# 执行结果
a b c
```

如下示例所示，因为`d`是宏观任务，因此，它不会先于`c`执行，哪怕。

```javascript
var r = new Promise(function(resolve, reject){
    console.log("a");
    resolve()
});
setTimeout(()=>console.log("d"), 0)
r.then(() => console.log("c"));
console.log("b")
# 执行结果
a b c d
```



## 异步执行顺序

1. 首先我们分析有多少个宏观任务
2. 在每个宏观任务中，分析有多少个微观任务
3. 根据调用次序，确定宏观任务中的微观任务执行次序
4. 根据宏观任务的触发规则和调用次序，确定宏观任务的执行次序
5. 确定整个顺序



## async/await

async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。

async 函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。

```javascript
# 变化红绿灯，绿灯3秒、黄灯1秒、红灯2秒
const elm = document.getElementById("Trflight");

async function sleep(duration) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,duration);
    })
}
async function changeLight(duration, color){
    await sleep(duration).then( () => { elm.style.backgroundColor = color; })
    console.log("ChangeColor: " + color);
}
async function main(){
    while (true) {
        await changeLight(3000, "green");
        await changeLight(1000, "yellow");
        await changeLight(2000, "red");
    }
}

main();
```

generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。



# JavaScript中函数的执行

## 闭包

`Closure`即绑定了执行环境的函数。

> 就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。

