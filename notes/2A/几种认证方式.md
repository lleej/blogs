# CAS

## 解决

多个系统只需登录一次，无需重复登录

## 角色

1. 授权服务器(S)
2. 被授权客户端(C)

## 原理

1. `S`保存全局`session`，`C`各自保存自己的`session`
2. `C`登录时判断自己的`session`是否已登录
3. 未登录，则重定向到`S`进行授权
4. `S`判断全局的`session`是否已登录
5. 未登录，则重定向到登录页面进行登录，成功后将`ticket`返回`C`
6. `C`收到`ticket`后，请求`S`获取用户信息
7. `S`同意客户端授权后，保存用户信息到全局`session`，`C`保存到本地

## 不足

1. 对微服务化和前后端分离支持性较差

# OAuth2

最流行的授权机制，授权第三方应用使用用户数据

## 解决

1. 第三方应用访问主系统资源，用户无需将其在主系统的账号告知第三方应用
2. 主系统资源的所有者将访问令牌(token)授权给第三方应用
3. 第三方应用使用访问令牌(token)，使用主系统的资源
4. 访问令牌(token)等同于用户密码，令牌(token)可以随时失效

## 举例

1. 终端用户（资源所有者）可以许可一个打印服务（客户端）访问他存储在图片分享网站（资源服务器）上的受保护图片，而无需与打印服务分享自己的用户名和密码
2. 他直接与图片分享网站信任的服务器（授权服务器）进行身份验证，该服务器颁发给打印服务具体的委托凭据（访问令牌）

## 角色

1. 资源所有者(RO)

   能够许可对受保护资源的访问权限的**实体**。当资源所有者是个人时，被称为最终用户

2. 资源服务器 (RS)

   托管受保护资源的服务器，能够接受和响应使用访问令牌对受保护资源的请求

3. 客户端(C)

   使用资源所有者的授权，代表资源所有者发起对受保护资源的请求的**应用程序**。并非特指任何特定的实现特点（例如：应用程序是否是在服务器、台式机或其他设备上执行）

4. 授权服务器(AS)

   在成功验证资源所有者且获得授权后，**颁发访问令牌**给客户端的服务器

授权服务器可以和资源服务器是同一台服务器，也可以是分离的个体。一个授权服务器可以颁发被多个资源服务器接受的访问令牌

## 原理

### 协议流程

![OAuth抽象协议流程](./assets/OAuth-abstract-flow.png)

- （A）客户端从资源所有者处请求授权。授权请求可以直接向资源所有者发起，或者更可取的是通过授权服务器作为中介间接发起
- （B）客户端收到授权许可，这是一个代表资源所有者的授权的凭据，使用本规范中定义的四种许可类型之一或者使用扩展许可类型表示。授权许可类型取决于客户端请求授权所使用的方法以及授权服务器支持的类型
- （C）客户端与授权服务器进行身份认证并出示授权许可以请求访问令牌
- （D）授权服务器验证客户端身份并验证授权许可，若有效则颁发访问令牌
- （E）客户端从资源服务器请求受保护资源并出示访问令牌进行身份验证
- （F）资源服务器验证访问令牌，若有效则处理该请求

客户端从资源所有者获得授权许可（步骤（A）和（B）所示）的更好方法是使用授权服务器作为中介

### 授权许可

授权许可是一个代表资源所有者授权（访问受保护资源）的凭据，客户端用它来获取访问令牌。

OAuth定义了四种许可类型：

1. 授权码

2. 隐式许可

   针对于客户端没有后端的情况，客户端不需要为`OAuth`改造其后端代码，而是使用`JavaScript`脚本语言在浏览器中实现客户端

3. 资源所有者密码凭据

4. 客户端凭据

## 不足



# OIDC

> OpenID Connect

基于 `OAuth 2.0` 协议的轻量认证级规范，提供通过`API`进行身份交互的框架。

较`OAuth`而言，`OpenID Connect` 方式除了认证请求之外，还标明请求的用户身份

# JWT

> JSON Web Token

`JWT`是一个轻巧的规范，允许我们使用`JWT`在用户和服务器之间传递安全可靠的信息

## 场景

A用户关注了B用户后，系统发送邮件给B用户，可以通过以下链接关注A用户

```shell
https://your.awesome-app.com/make-friend/?from_user=B&target_user=A
```

在`URL`中明文传递信息，安全性较差。而且B用户必须要登录系统，才能被允许执行

## 组成

`JWT`是一个字符串，由三部分组成

### 载荷(Payload)

包含`JWT`标准定义的数据以及要传递的用户信息

```python
{
    "iss": "John Wu JWT", #JWT的签发者
    "iat": 1441593502, # 签发时间
    "exp": 1441594722, # 过期时间
    "aud": "www.example.com", # JWT的接收方
    "sub": "jrocket@example.com", # JWT面向的用户
    "from_user": "B", # 用户信息
    "target_user": "A" # 用户信息
}
```

对载荷部分进行`Base64`编码，得到字符串

### 头部(Header)

描述`JWT`的基本信息，例如类型和算法等

```python
{
  "typ": "JWT", # 类型
  "alg": "HS256" # 加密算法
}
```

对头部部分进行`Base64`编码，得到字符串

### 签名(Signature)

用`.`连接头部和载荷字符串，并将该字符串进行加密，得到`JWT`的签名部分

将签名部分添加到字符串的结尾，用`.`连接。示例如下：

```python
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
```

## 使用

在`SSO`中，用户登录成功后，将用户信息通过`JWT`处理后，保存到客户端的`Cookie`中

每次向服务器请求时，都会将`JWT`信息发送到服务端，服务端对签名、接收方、有效期进行校验...

校验通过后，从`JWT`中获取用户信息

## 与`Session`的差异

`Session`方式：服务端需要占用内存或缓存来存储大量的用户信息，多台服务器间需要同步`Session`信息

`JWT`方式：将用户信息分散到客户端中，服务器需要的是计算能力(编解码、加解密)

# SSO



# 对比

![image-20190626082601798](./assets/java_compare.png)

